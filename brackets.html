<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tournament Bracket</title>
  <!-- Alpine.js -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      overflow: hidden;
    }

    .tournament-container {
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 20px;
      min-height: 80vh;
      width: max-content; /* Ensure it takes as much width as needed */
    }

    .bracket-column {
      position: relative; /* Create positioning context for absolute children */
      margin-right: 40px;
      height: 40vh; /* Default height, will be overridden dynamically if needed */
      padding-top: 5vh; /* Scaled down by 50% from 10vh */
      padding-bottom: 5vh; /* Scaled down by 50% from 10vh */
      width: 200px; /* Match the width of matches */
    }

    .match {
      position: relative;
      width: 200px;
      margin: 10px 0; /* Increased vertical margin for better spacing */
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      overflow: hidden;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .match:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .player {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .player:hover {
      background-color: #f5f5f5;
    }

    .player:last-child {
      border-bottom: none;
    }

    .player.winner {
      background-color: #e8f5e9;
      font-weight: bold;
    }

    .connector {
      position: absolute;
      right: -40px;
      width: 40px;
      border-top: 2px solid #ccc;
    }

    /* We're now using only horizontal connectors with the new positioning */
    .connector.horizontal {
      top: 50%;
      transform: translateY(-50%);
    }

    /* Curved connectors to connect match pairings with the next level */
    .connector-curved {
      position: absolute;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .connector-curved path {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    .match-number {
      position: absolute;
      top: -20px;
      left: 10px;
      font-size: 12px;
      color: #999;
    }

    .winner-trophy {
      font-size: 24px;
      color: gold;
      margin-left: 10px;
    }

    .title {
      text-align: center;
      margin-bottom: 10px;
      color: #333;
      font-size: 2.5rem;
    }

    .tournament-info {
      text-align: center;
      margin-bottom: 20px;
      color: #666;
      background-color: #fff;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .tournament-info p {
      margin: 5px 0;
    }

    /* Zoom and drag container */
    .zoom-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 150px);
      overflow: hidden;
      cursor: grab;
    }

    .zoom-container.grabbing {
      cursor: grabbing;
    }

    .zoom-content {
      transform-origin: 0 0;
      position: absolute;
      /* Removed transition for more responsive panning */
    }

    /* Reset zoom button */
    .reset-zoom-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .reset-zoom-btn:hover {
      background-color: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .reset-zoom-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    @media (max-width: 768px) {
      .tournament-container {
        flex-direction: column;
        align-items: flex-start;
      }

      .bracket-column {
        margin-right: 0;
        margin-bottom: 20px;
        width: 100%;
      }

      .match {
        width: 100%;
      }

      .connector {
        display: none;
      }
    }
  </style>
</head>
<body>
<h1 class="title">Nexus Tournament Bracket</h1>
<div id="tournament-info" class="tournament-info">
  <p>Single elimination tournament bracket. Number of players: <span id="player-count">8</span></p>
  <p>Use the URL parameter "?players=X" to change the number of players. Supports any number of players (not just powers of 2).</p>
  <p>Drag to pan, use mouse wheel or pinch to zoom.</p>
</div>

<div x-data="bracketViewer()"
     class="zoom-container"
     x-ref="container"
     @mousedown="startDrag"
     @mousemove="drag"
     @mouseup="stopDrag"
     @mouseleave="stopDrag"
     @touchstart="startTouchDrag"
     @touchmove="touchDrag"
     @touchend="stopDrag"
     @wheel="zoom">

  <div class="zoom-content"
       x-ref="content"
       :style="`transform: translate(${translateX}px, ${translateY}px) scale(${scale})`">
    <div id="tournament-container" class="tournament-container">
      <!-- Bracket will be generated here -->
    </div>
  </div>

  <button class="reset-zoom-btn"
          x-show="scale !== 1 || translateX !== initialTranslateX || translateY !== initialTranslateY"
          @click="resetZoom">
    ⊕
  </button>
</div>

<script>
  // Alpine.js component for bracket viewer with zoom and drag functionality
  function bracketViewer() {
    return {
      scale: 1,
      translateX: 0,
      translateY: 0,
      initialTranslateX: 0,
      initialTranslateY: 0,
      isDragging: false,
      lastX: 0,
      lastY: 0,
      lastDistance: 0,

      // Mouse drag handlers
      startDrag(e) {
        if (e.button !== 0) return; // Only left mouse button
        this.isDragging = true;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        this.$refs.container.classList.add('grabbing');
        e.preventDefault();
      },

      drag(e) {
        if (!this.isDragging) return;
        const deltaX = e.clientX - this.lastX;
        const deltaY = e.clientY - this.lastY;
        this.translateX += deltaX;
        this.translateY += deltaY;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        e.preventDefault();
      },

      stopDrag() {
        this.isDragging = false;
        this.$refs.container.classList.remove('grabbing');
      },

      // Touch drag handlers
      startTouchDrag(e) {
        if (e.touches.length === 1) {
          // Single touch for dragging
          this.isDragging = true;
          this.lastX = e.touches[0].clientX;
          this.lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Two touches for pinch zoom
          this.lastDistance = this.getTouchDistance(e);
        }
        e.preventDefault();
      },

      touchDrag(e) {
        if (e.touches.length === 1 && this.isDragging) {
          // Single touch drag
          const deltaX = e.touches[0].clientX - this.lastX;
          const deltaY = e.touches[0].clientY - this.lastY;
          this.translateX += deltaX;
          this.translateY += deltaY;
          this.lastX = e.touches[0].clientX;
          this.lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Pinch zoom
          const currentDistance = this.getTouchDistance(e);
          const delta = currentDistance - this.lastDistance;

          if (Math.abs(delta) > 5) {
            // Calculate zoom center point
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;

            // Zoom in or out
            const zoomDirection = delta > 0 ? 1 : -1;
            this.zoomAtPoint(centerX, centerY, zoomDirection * 0.05);

            this.lastDistance = currentDistance;
          }
        }
        e.preventDefault();
      },

      // Helper for touch distance
      getTouchDistance(e) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        return Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
      },

      // Mouse wheel zoom
      zoom(e) {
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        this.zoomAtPoint(e.clientX, e.clientY, delta);
        e.preventDefault();
      },

      // Zoom at specific point
      zoomAtPoint(clientX, clientY, delta) {
        // Get container bounds
        const rect = this.$refs.container.getBoundingClientRect();

        // Calculate mouse position relative to container
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // Calculate mouse position in scaled content space
        const contentX = (x - this.translateX) / this.scale;
        const contentY = (y - this.translateY) / this.scale;

        // Calculate new scale with limits
        const newScale = Math.max(0.5, Math.min(3, this.scale + delta));

        // Calculate new translate values to zoom at mouse position
        if (newScale !== this.scale) {
          this.translateX = x - contentX * newScale;
          this.translateY = y - contentY * newScale;
          this.scale = newScale;
        }
      },

      // Reset zoom and center
      resetZoom() {
        this.scale = 1;

        // Center the bracket in the viewport
        const container = this.$refs.container;
        const content = this.$refs.content;

        if (container && content) {
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const contentWidth = content.scrollWidth;
          const contentHeight = content.scrollHeight;

          this.translateX = (containerWidth - contentWidth) / 2;
          this.translateY = (containerHeight - contentHeight) / 2;

          // Store the initial centered position
          this.initialTranslateX = this.translateX;
          this.initialTranslateY = this.translateY;
        } else {
          this.translateX = 0;
          this.translateY = 0;
          this.initialTranslateX = 0;
          this.initialTranslateY = 0;
        }
      }
    };
  }


  document.addEventListener('DOMContentLoaded', function() {
    // Get the number of players from the URL query parameter, default to 8
    const urlParams = new URLSearchParams(window.location.search);
    let numPlayers = parseInt(urlParams.get('players')) || 8;

    // Ensure the number of players is at least 2
    numPlayers = Math.max(2, numPlayers);

    // Update player count display
    document.getElementById('player-count').textContent = numPlayers;

    // Generate the bracket
    generateBracket(numPlayers);

    // Prevent default touch behavior on the zoom container to avoid conflicts
    const zoomContainer = document.querySelector('.zoom-container');
    zoomContainer.addEventListener('touchstart', function(e) {
      // Allow default behavior for buttons
      if (e.target.tagName === 'BUTTON') return;
      e.preventDefault();
    }, { passive: false });

  });


  // Function to get the next power of 2 greater than or equal to n
  function getNextPowerOfTwo(n) {
    let power = 1;
    while (power < n) {
      power *= 2;
    }
    return power;
  }

  // Function to create a curved connector between two elements
  function createCurvedConnector(sourceElement, targetElement, container, isUpperConnection) {
    // Create SVG element for the curved connector
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "connector-curved");
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";

    // Create path element
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

    // Get positions relative to the container
    const sourceRect = sourceElement.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Calculate start and end points
    const startX = sourceRect.right - containerRect.left;
    const startY = sourceRect.top + sourceRect.height / 2 - containerRect.top;
    const endX = targetRect.left - containerRect.left;

    // Adjust the end Y position based on whether this is an upper or lower connection
    // For upper connections, move the end point higher by half a player slot's height
    // For lower connections, move the end point lower by half a player slot's height
    const playerSlotHeight = targetRect.height / 2; // Height of a single player slot
    const endY = isUpperConnection
      ? targetRect.top + playerSlotHeight / 2 - containerRect.top // Upper connection
      : targetRect.top + targetRect.height - playerSlotHeight / 2 - containerRect.top; // Lower connection

    // Calculate control points for the curve
    const controlX = startX + (endX - startX) / 2;

    // Create the path data for a cubic bezier curve
    const pathData = `M ${startX},${startY} C ${controlX},${startY} ${controlX},${endY} ${endX},${endY}`;

    path.setAttribute("d", pathData);
    svg.appendChild(path);

    return svg;
  }

  // Function to handle player click and toggle winner status
  function handlePlayerClick(event) {
    const player = event.currentTarget;
    const match = player.closest('.match');

    // Don't allow clicking in the champion round (last round)
    // Check if this is the final round by looking for a match in the next round
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);

    // If there's no next match or this is the champion round (has a trophy), don't allow toggling
    if (!nextMatch || match.querySelector('.winner-trophy')) {
      return;
    }

    // Toggle winner status for the clicked player
    const isWinner = player.classList.toggle('winner');

    // If this player is now a winner, remove winner class from any sibling
    if (isWinner) {
      const siblings = match.querySelectorAll('.player');
      siblings.forEach(sibling => {
        if (sibling !== player && sibling.classList.contains('winner')) {
          sibling.classList.remove('winner');
        }
      });

      // Update the next match with this player's name
      updateNextMatch(match, player);
    } else {
      // If no winner is selected, clear the next match slot
      clearNextMatchSlot(match);
    }
  }

  // Function to update the next match with the winner's name
  function updateNextMatch(match, winnerPlayer) {
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);

    // Find the next match element
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);
    if (!nextMatch) return;

    // Determine if this is the upper or lower player in the next match
    const isUpper = matchIndex % 2 === 0;
    const playerIndex = isUpper ? 0 : 1;

    // Get the player elements in the next match
    const nextMatchPlayers = nextMatch.querySelectorAll('.player');
    if (nextMatchPlayers.length <= playerIndex) return;

    // Update the player text in the next match
    const playerName = winnerPlayer.textContent;
    nextMatchPlayers[playerIndex].textContent = playerName;
  }

  // Function to clear the next match slot when no winner is selected
  function clearNextMatchSlot(match) {
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);

    // Find the next match element
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);
    if (!nextMatch) return;

    // Determine if this is the upper or lower player in the next match
    const isUpper = matchIndex % 2 === 0;
    const playerIndex = isUpper ? 0 : 1;

    // Get the player elements in the next match
    const nextMatchPlayers = nextMatch.querySelectorAll('.player');
    if (nextMatchPlayers.length <= playerIndex) return;

    // Reset the player text in the next match to the default
    const sourceMatchNum = parseInt(match.querySelector('.match-number').textContent.replace('Match ', ''));
    nextMatchPlayers[playerIndex].textContent = `Winner of Match ${sourceMatchNum}`;
  }

  // Function to generate the tournament bracket
  function generateBracket(numPlayers) {
    const container = document.getElementById('tournament-container');
    container.innerHTML = '';

    // Calculate the number of rounds needed based on the ceiling of log2
    // Add 1 to include the champion round
    const numRounds = Math.ceil(Math.log2(numPlayers)) + 1;

    // Store match elements for each round to create connectors later
    const matchesByRound = [];

    // Store the match sources to track which matches feed into which
    const matchSources = {};

    // Calculate the number of players that get a "bye" in the first round
    const totalMatchesNeeded = numPlayers - 1; // Total matches needed for a tournament
    // Subtract 1 from numRounds to account for the champion round
    const firstRoundMatches = Math.max(0, numPlayers - Math.pow(2, numRounds - 2)); // Matches in the first round
    const byeCount = Math.pow(2, numRounds - 1) - numPlayers; // Number of players that get a bye

    // Generate each round
    for (let round = 0; round < numRounds; round++) {
      const column = document.createElement('div');
      column.className = 'bracket-column';

      // Calculate the number of matches in this round
      let numMatches;
      if (round === 0) {
        // First round has matches for players without byes
        numMatches = firstRoundMatches;
      } else if (round === numRounds - 1 || round === numRounds - 2) {
        // Finals and Champion rounds always have 1 match
        numMatches = 1;
      } else {
        // Intermediate rounds
        // Calculate how many matches we need in this round based on the previous round
        // and the number of players with byes that enter in this round
        if (round === 1 && firstRoundMatches === 0) {
          // Special case: if there are no first round matches (power of 2),
          // then the second round has numPlayers/2 matches
          numMatches = numPlayers / 2;
        } else if (round === 1) {
          // Second round combines winners from first round and players with byes
          numMatches = Math.ceil(firstRoundMatches / 2) + Math.floor(byeCount / 2);
        } else {
          // Later rounds just have half as many matches as the previous round
          numMatches = Math.ceil(matchesByRound[round-1].length / 2);
        }
      }

      // Calculate the minimum height needed based on the number of matches in the first round
      // Each match needs at least 80px of vertical space (2 players + margins)
      // We convert this to vh units for consistent sizing
      const minHeightPerMatch = 10; // in vh units

      // Calculate the total height needed for the first round
      // We use the maximum of the default height (40vh) and the calculated height
      const calculatedTotalHeight = firstRoundMatches > 0
        ? Math.max(40, firstRoundMatches * minHeightPerMatch)
        : 40; // Default to 40vh for power-of-two tournaments

      // Set the height of the column
      column.style.height = `${calculatedTotalHeight}vh`;

      // Use the same totalHeight for positioning calculations
      const totalHeight = calculatedTotalHeight;

      // Store matches for this round
      matchesByRound[round] = [];

      // Generate the matches for this round
      for (let match = 0; match < numMatches; match++) {
        const matchElement = document.createElement('div');
        matchElement.className = 'match';
        matchElement.dataset.round = round;
        matchElement.dataset.match = match;

        // Position matches using absolute positioning
        // For non-power-of-two tournaments, we need to adjust the positioning

        // Calculate the total slots in the final round (always power of 2)
        // Subtract 1 from numRounds to account for the champion round
        const finalRoundSlots = Math.pow(2, numRounds - 2);

        // For the first round with non-power-of-two players
        if (round === 0) {
          // Calculate the position based on match index, accounting for byes
          const positionPercentage = ((match + 0.5) / (firstRoundMatches > 0 ? firstRoundMatches : 1)) * totalHeight;

          // Set absolute positioning
          matchElement.style.position = 'absolute';
          matchElement.style.top = positionPercentage + 'vh';
        } else {
          // For later rounds, position matches to align with their predecessors
          // Calculate the position of this match in the binary tree
          const matchPosition = match + 0.5;

          // Calculate the percentage of the total height
          const positionPercentage = (matchPosition / (numMatches > 0 ? numMatches : 1)) * totalHeight;

          // Set absolute positioning for precise pyramid alignment
          matchElement.style.position = 'absolute';
          matchElement.style.top = positionPercentage + 'vh';
        }

        // Add match number
        const matchNumber = document.createElement('div');
        matchNumber.className = 'match-number';

        // Calculate match number based on round and match index
        let matchNumberValue;
        if (round === 0) {
          matchNumberValue = match + 1;
        } else {
          // For later rounds, calculate based on previous rounds
          let previousRoundsMatches = 0;
          for (let r = 0; r < round; r++) {
            previousRoundsMatches += matchesByRound[r].length;
          }
          matchNumberValue = previousRoundsMatches + match + 1;
        }

        matchNumber.textContent = `Match ${matchNumberValue}`;
        matchElement.appendChild(matchNumber);

        // Create a unique ID for this match
        const matchId = `r${round}m${match}`;
        matchElement.dataset.matchId = matchId;

        if (round === 0) {
          // First round - create player pairings
          const player1 = document.createElement('div');
          player1.className = 'player';
          player1.textContent = `Player ${match * 2 + 1}`;
          player1.addEventListener('click', handlePlayerClick);

          const player2 = document.createElement('div');
          player2.className = 'player';
          player2.textContent = `Player ${match * 2 + 2}`;
          player2.addEventListener('click', handlePlayerClick);

          matchElement.appendChild(player1);
          matchElement.appendChild(player2);

          // Track which match in the next round this match feeds into
          // For non-power-of-two tournaments, the mapping might be different
          // We need to ensure matches are paired correctly in the next round
          let nextRoundMatch;

          if (round === 0 && firstRoundMatches < numPlayers / 2) {
            // For the first round in non-power-of-two tournaments,
            // we need to calculate which match in the next round this feeds into
            nextRoundMatch = Math.floor(match / 2);
          } else {
            // Standard pairing
            nextRoundMatch = Math.floor(match / 2);
          }

          const nextMatchId = `r${round + 1}m${nextRoundMatch}`;

          if (!matchSources[nextMatchId]) {
            matchSources[nextMatchId] = [];
          }
          matchSources[nextMatchId].push({
            matchId,
            isUpper: match % 2 === 0
          });

        } else if (round === numRounds - 1) {
          // Champion round - show the winner
          const winner = document.createElement('div');
          winner.className = 'player winner';
          winner.innerHTML = `Champion <span class="winner-trophy">🏆</span>`;
          matchElement.appendChild(winner);
        } else {
          // Intermediate rounds
          // For non-power-of-two tournaments, we need to handle players with byes

          // Get the sources for this match
          const sources = matchSources[matchId] || [];

          // If we have fewer than 2 sources, some players had byes
          if (sources.length < 2) {
            // First player might be from a previous match or have a bye
            if (sources.length > 0 && sources[0].isUpper) {
              // Player from previous match
              const player1 = document.createElement('div');
              player1.className = 'player';
              const sourceMatchNum = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
              player1.textContent = `Winner of Match ${sourceMatchNum}`;
              player1.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player1);
            } else {
              // Player with a bye
              const player1 = document.createElement('div');
              player1.className = 'player';
              // Calculate player number based on round and match
              // For the first round with byes, we need to assign player numbers correctly
              // Players with byes start at firstRoundMatches*2+1
              const playerNum = firstRoundMatches * 2 + 1 + (match * 2);
              player1.textContent = `Player ${playerNum}`;
              player1.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player1);
            }

            // Second player might be from a previous match or have a bye
            if (sources.length > 0 && !sources[0].isUpper) {
              // Player from previous match
              const player2 = document.createElement('div');
              player2.className = 'player';
              const sourceMatchNum = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
              player2.textContent = `Winner of Match ${sourceMatchNum}`;
              player2.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player2);
            } else {
              // Player with a bye
              const player2 = document.createElement('div');
              player2.className = 'player';
              // Calculate player number based on round and match
              // For the first round with byes, we need to assign player numbers correctly
              // Players with byes start at firstRoundMatches*2+1
              const playerNum = firstRoundMatches * 2 + 1 + (match * 2 + 1);
              player2.textContent = `Player ${playerNum}`;
              player2.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player2);
            }
          } else {
            // Normal case - both players from previous matches
            const player1 = document.createElement('div');
            player1.className = 'player';
            const sourceMatchNum1 = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
            player1.textContent = `Winner of Match ${sourceMatchNum1}`;
            player1.addEventListener('click', handlePlayerClick);

            const player2 = document.createElement('div');
            player2.className = 'player';
            const sourceMatchNum2 = parseInt(sources[1].matchId.substring(sources[1].matchId.indexOf('m') + 1)) + 1;
            player2.textContent = `Winner of Match ${sourceMatchNum2}`;
            player2.addEventListener('click', handlePlayerClick);

            matchElement.appendChild(player1);
            matchElement.appendChild(player2);
          }

          // Track which match in the next round this match feeds into
          if (round < numRounds - 1) {
            // For intermediate rounds and finals, calculate which match in the next round this feeds into
            // Standard pairing for binary tournament
            const nextRoundMatch = Math.floor(match / 2);
            const nextMatchId = `r${round + 1}m${nextRoundMatch}`;

            if (!matchSources[nextMatchId]) {
              matchSources[nextMatchId] = [];
            }
            matchSources[nextMatchId].push({
              matchId,
              isUpper: match % 2 === 0
            });
          }
        }

        // Store the match element for later connector creation
        matchesByRound[round][match] = matchElement;

        column.appendChild(matchElement);
      }

      container.appendChild(column);
    }

    // Create curved connectors between match pairings and their next-level match
    // For each match, find its sources and create connectors
    for (let round = 1; round < numRounds; round++) {
      for (let match = 0; match < matchesByRound[round].length; match++) {
        const targetMatch = matchesByRound[round][match];
        const targetMatchId = `r${round}m${match}`;
        const sources = matchSources[targetMatchId] || [];

        // Create connectors for each source
        for (const source of sources) {
          // Find the source match element
          const sourceRound = parseInt(source.matchId.substring(1, source.matchId.indexOf('m')));
          const sourceMatch = parseInt(source.matchId.substring(source.matchId.indexOf('m') + 1));
          const sourceMatchElement = matchesByRound[sourceRound][sourceMatch];

          // Create curved connector between this match and its target
          const curvedConnector = createCurvedConnector(sourceMatchElement, targetMatch, container, source.isUpper);
          container.appendChild(curvedConnector);
        }
      }
    }
  }
</script>
</body>
</html>
<script>
  (function() {
    var ws = new WebSocket('ws://' + window.location.host +
      '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
      'referrer=' + encodeURIComponent(window.location.pathname));
    ws.onmessage = function (msg) {
      if (msg.data === 'reload') {
        window.location.reload();
      }
      if (msg.data.startsWith('update-css ')) {
        var messageId = msg.data.substring(11);
        var links = document.getElementsByTagName('link');
        for (var i = 0; i < links.length; i++) {
          var link = links[i];
          if (link.rel !== 'stylesheet') continue;
          var clonedLink = link.cloneNode(true);
          var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
          if (newHref !== link.href) {
            clonedLink.href = newHref;
          }
          else {
            var indexOfQuest = newHref.indexOf('?');
            if (indexOfQuest >= 0) {
              // to support ?foo#hash
              clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' +
                newHref.substring(indexOfQuest + 1);
            }
            else {
              clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
            }
          }
          link.replaceWith(clonedLink);
        }
      }
    };
  })();
</script>
