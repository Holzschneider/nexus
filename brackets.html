<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tournament Bracket</title>
  <!-- Alpine.js -->
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      overflow: hidden;
    }

    .info-button {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 20px;
      background-color: #4CAF50;
      color: white;
      font-size: 24px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: all 0.2s ease, color 0.3s ease;
      overflow: hidden;
    }

    .info-button:hover {
      top: 20px;
      right: 20px;
      width: 400px;
      height: 200px;
      border-radius: 5px;
      justify-content: flex-start;
      align-items: flex-start;
      padding: 5px;
      transform: none;
      color: white;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    .info-button .question-mark {
      transition: opacity 0.2s ease;
    }

    .info-button:hover .question-mark {
      opacity: 0;
      position: absolute;
    }

    .tournament-container {
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 20px;
      min-height: 80vh;
      width: max-content; /* Ensure it takes as much width as needed */
    }

    .bracket-column {
      position: relative; /* Create positioning context for absolute children */
      margin-right: 40px;
      height: 40vh; /* Default height, will be overridden dynamically if needed */
      padding-top: 5vh; /* Scaled down by 50% from 10vh */
      padding-bottom: 5vh; /* Scaled down by 50% from 10vh */
      width: 250px; /* Increased width for player names */
    }

    /* Visual separation between columns - centered between columns */
    .bracket-column:not(:first-child)::before {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: -20px; /* Half of the margin-right to center it */
      border-left: 1px dashed #e6e6e6; /* Lighter dashed line */
    }

    .column-name {
      position: fixed;
      bottom: 20px;
      text-align: center;
      font-weight: bold;
      font-size: 16px;
      font-style: italic;
      background: transparent;
      padding: 8px 12px;
      z-index: 100;
      transform: translateX(-50%); /* Center the name under the column */
      white-space: nowrap;
    }

    .column-name .check-mark {
      display: none;
      color: #4CAF50;
      margin-left: 5px;
    }

    .column-name .check-mark.visible {
      display: inline;
    }

    .match {
      position: relative;
      width: 250px; /* Increased width to match column width */
      margin: 10px 0; /* Increased vertical margin for better spacing */
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      overflow: hidden;
      transition: box-shadow 0.3s ease;
    }

    .match:hover {
      box-shadow: 0 4px 10px rgba(0,0,0,0.25);
    }

    .player {
      padding: 10px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background-color 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player:hover {
      background-color: #f5f5f5;
    }

    .player:last-child {
      border-bottom: none;
    }

    .player.winner {
      background-color: #e8f5e9;
      font-weight: bold;
    }

    .connector {
      position: absolute;
      right: -40px;
      width: 40px;
      border-top: 2px solid #ccc;
    }

    /* We're now using only horizontal connectors with the new positioning */
    .connector.horizontal {
      top: 50%;
      transform: translateY(-50%);
    }

    /* Curved connectors to connect match pairings with the next level */
    .connector-curved {
      position: absolute;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .connector-curved path {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }

    .match-number {
      position: absolute;
      top: -20px;
      left: 10px;
      font-size: 12px;
      color: #999;
    }

    .winner-trophy {
      font-size: 24px;
      color: gold;
      margin-left: 10px;
    }

    .title {
      text-align: center;
      margin-bottom: 10px;
      color: #333;
      font-size: 2.5rem;
    }

    .info-content {
      opacity: 0;
      transition: opacity 0.2s ease;
      text-align: left;
      color: #444;
      width: 100%;
      display: none;
      font-size: 0.92rem;
      font-style: normal;
      font-weight: normal;
    }

    .info-button:hover .info-content {
      opacity: 0;
      display: block;
      transition-delay: 0.3s;
    }

    .info-button:hover:active .info-content,
    .info-button:hover .info-content {
      animation: fadeInContent 0.1s ease 0.2s forwards;
    }

    @keyframes fadeInContent {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    .info-content p {
      margin: 2px 0;
    }
    .info-button:hover  {
      opacity: 1;
    }


    /* Zoom and drag container */
    .zoom-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 150px);
      overflow: hidden;
      cursor: grab;
    }

    .zoom-container.grabbing {
      cursor: grabbing;
    }

    .zoom-content {
      transform-origin: 0 0;
      position: absolute;
      /* Removed transition for more responsive panning */
    }

    /* Reset zoom button */
    .reset-zoom-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .reset-zoom-btn:hover {
      background-color: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .reset-zoom-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    @media (max-width: 768px) {
      .tournament-container {
        flex-direction: column;
        align-items: flex-start;
      }

      .bracket-column {
        margin-right: 0;
        margin-bottom: 20px;
        width: 100%;
      }

      .match {
        width: 100%;
      }

      .connector {
        display: none;
      }
    }
  </style>
</head>
<body>
<h1 class="title">Nexus Tournament Bracket</h1>
<div id="info-button" class="info-button">
  <span class="question-mark">?</span>
  <div class="info-content">
    <h2><div style="text-align: center;">Single elimination tournament bracket: <span id="player-count">8</span> players</div></h2>
    <ul>
      <li>Use the URL parameter "?players=X" to change the number of players (e.g., "?players=5").</li>
      <li>Or use a comma-separated list of player names (e.g., "?players=Philipp,Sebastian,Andreas,Max,Dennis").</li>
      <li>Supports any number of players (not just powers of 2).</li>
      <li>Drag to pan, use mouse wheel or pinch to zoom.</li>
    </ul>
  </div>
</div>

<div x-data="bracketViewer()"
     class="zoom-container"
     x-ref="container"
     @mousedown="startDrag"
     @mousemove="drag"
     @mouseup="stopDrag"
     @mouseleave="stopDrag"
     @touchstart="startTouchDrag"
     @touchmove="touchDrag"
     @touchend="stopDrag"
     @wheel="zoom">

  <div class="zoom-content"
       x-ref="content"
       :style="`transform: translate(${translateX}px, ${translateY}px) scale(${scale})`">
    <div id="tournament-container" class="tournament-container">
      <!-- Bracket will be generated here -->
    </div>
  </div>

  <button class="reset-zoom-btn"
          x-show="scale !== 1 || translateX !== initialTranslateX || translateY !== initialTranslateY"
          @click="resetZoom">
    ⊕
  </button>
</div>

<script>
  // Alpine.js component for bracket viewer with zoom and drag functionality
  function bracketViewer() {
    return {
      scale: 1,
      translateX: 0,
      translateY: 0,
      initialTranslateX: 0,
      initialTranslateY: 0,
      isDragging: false,
      lastX: 0,
      lastY: 0,
      lastDistance: 0,

      // Mouse drag handlers
      startDrag(e) {
        if (e.button !== 0) return; // Only left mouse button
        this.isDragging = true;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        this.$refs.container.classList.add('grabbing');
        e.preventDefault();
      },

      drag(e) {
        if (!this.isDragging) return;
        const deltaX = e.clientX - this.lastX;
        const deltaY = e.clientY - this.lastY;
        this.translateX += deltaX;
        this.translateY += deltaY;
        this.lastX = e.clientX;
        this.lastY = e.clientY;
        e.preventDefault();
      },

      stopDrag() {
        this.isDragging = false;
        this.$refs.container.classList.remove('grabbing');
      },

      // Touch drag handlers
      startTouchDrag(e) {
        if (e.touches.length === 1) {
          // Single touch for dragging
          this.isDragging = true;
          this.lastX = e.touches[0].clientX;
          this.lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Two touches for pinch zoom
          this.lastDistance = this.getTouchDistance(e);
        }
        e.preventDefault();
      },

      touchDrag(e) {
        if (e.touches.length === 1 && this.isDragging) {
          // Single touch drag
          const deltaX = e.touches[0].clientX - this.lastX;
          const deltaY = e.touches[0].clientY - this.lastY;
          this.translateX += deltaX;
          this.translateY += deltaY;
          this.lastX = e.touches[0].clientX;
          this.lastY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          // Pinch zoom
          const currentDistance = this.getTouchDistance(e);
          const delta = currentDistance - this.lastDistance;

          if (Math.abs(delta) > 5) {
            // Calculate zoom center point
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;

            // Zoom in or out
            const zoomDirection = delta > 0 ? 1 : -1;
            this.zoomAtPoint(centerX, centerY, zoomDirection * 0.05);

            this.lastDistance = currentDistance;
          }
        }
        e.preventDefault();
      },

      // Helper for touch distance
      getTouchDistance(e) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        return Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
      },

      // Mouse wheel zoom
      zoom(e) {
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        this.zoomAtPoint(e.clientX, e.clientY, delta);
        e.preventDefault();
      },

      // Zoom at specific point
      zoomAtPoint(clientX, clientY, delta) {
        // Get container bounds
        const rect = this.$refs.container.getBoundingClientRect();

        // Calculate mouse position relative to container
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        // Calculate mouse position in scaled content space
        const contentX = (x - this.translateX) / this.scale;
        const contentY = (y - this.translateY) / this.scale;

        // Calculate new scale with limits
        const newScale = Math.max(0.5, Math.min(3, this.scale + delta));

        // Calculate new translate values to zoom at mouse position
        if (newScale !== this.scale) {
          this.translateX = x - contentX * newScale;
          this.translateY = y - contentY * newScale;
          this.scale = newScale;
        }
      },

      // Reset zoom and center
      resetZoom() {
        this.scale = 1;

        // Center the bracket in the viewport
        const container = this.$refs.container;
        const content = this.$refs.content;

        if (container && content) {
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const contentWidth = content.scrollWidth;
          const contentHeight = content.scrollHeight;

          this.translateX = (containerWidth - contentWidth) / 2;
          this.translateY = (containerHeight - contentHeight) / 2;

          // Store the initial centered position
          this.initialTranslateX = this.translateX;
          this.initialTranslateY = this.translateY;
        } else {
          this.translateX = 0;
          this.translateY = 0;
          this.initialTranslateX = 0;
          this.initialTranslateY = 0;
        }
      }
    };
  }


  document.addEventListener('DOMContentLoaded', function() {
    // No event handlers needed for info button as it now uses CSS hover

    // Get the players from the URL query parameter, default to 8
    const urlParams = new URLSearchParams(window.location.search);
    const playersParam = urlParams.get('players') || '8';

    let numPlayers = 8;
    let playerNames = [];

    // Check if the players parameter is a number or a comma-separated list
    if (playersParam.includes(',')) {
      // It's a comma-separated list of player names
      playerNames = playersParam.split(',');
      numPlayers = playerNames.length;
    } else {
      // It's a number
      numPlayers = parseInt(playersParam) || 8;
      // Create default player names (Player 1, Player 2, etc.)
      for (let i = 1; i <= numPlayers; i++) {
        playerNames.push(`Player ${i}`);
      }
    }

    // Ensure the number of players is at least 2
    numPlayers = Math.max(2, numPlayers);
    if (playerNames.length < numPlayers) {
      // Add more default player names if needed
      for (let i = playerNames.length + 1; i <= numPlayers; i++) {
        playerNames.push(`Player ${i}`);
      }
    } else if (playerNames.length > numPlayers) {
      // Trim the player names array if needed
      playerNames = playerNames.slice(0, numPlayers);
    }

    // Generate the bracket
    generateBracket(numPlayers, playerNames);

    // Prevent default touch behavior on the zoom container to avoid conflicts
    const zoomContainer = document.querySelector('.zoom-container');
    zoomContainer.addEventListener('touchstart', function(e) {
      // Allow default behavior for buttons
      if (e.target.tagName === 'BUTTON') return;
      e.preventDefault();
    }, { passive: false });

    // Update player count display
    document.getElementById('player-count').textContent = numPlayers;
  });


  // Function to get the next power of 2 greater than or equal to n
  function getNextPowerOfTwo(n) {
    let power = 1;
    while (power < n) {
      power *= 2;
    }
    return power;
  }

  // Function to create a curved connector between two elements
  function createCurvedConnector(sourceElement, targetElement, container, isUpperConnection) {
    // Create SVG element for the curved connector
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("class", "connector-curved");
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";

    // Create path element
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

    // Get positions relative to the container
    const sourceRect = sourceElement.getBoundingClientRect();
    const targetRect = targetElement.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Calculate start and end points
    const startX = sourceRect.right - containerRect.left;
    const startY = sourceRect.top + sourceRect.height / 2 - containerRect.top;
    const endX = targetRect.left - containerRect.left;

    // Adjust the end Y position based on whether this is an upper or lower connection
    // For upper connections, move the end point higher by half a player slot's height
    // For lower connections, move the end point lower by half a player slot's height
    const playerSlotHeight = targetRect.height / 2; // Height of a single player slot
    const endY = isUpperConnection
      ? targetRect.top + playerSlotHeight / 2 - containerRect.top // Upper connection
      : targetRect.top + targetRect.height - playerSlotHeight / 2 - containerRect.top; // Lower connection

    // Calculate control points for the curve
    const controlX = startX + (endX - startX) / 2;

    // Create the path data for a cubic bezier curve
    const pathData = `M ${startX},${startY} C ${controlX},${startY} ${controlX},${endY} ${endX},${endY}`;

    path.setAttribute("d", pathData);
    svg.appendChild(path);

    return svg;
  }

  // Function to handle player click and toggle winner status
  function handlePlayerClick(event) {
    const player = event.currentTarget;
    const match = player.closest('.match');

    // Don't allow clicking in the champion round (last round)
    // Check if this is the final round by looking for a match in the next round
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);

    // If there's no next match or this is the champion round (has a trophy), don't allow toggling
    if (!nextMatch || match.querySelector('.winner-trophy')) {
      return;
    }

    // Toggle winner status for the clicked player
    const isWinner = player.classList.toggle('winner');

    // If this player is now a winner, remove winner class from any sibling
    if (isWinner) {
      const siblings = match.querySelectorAll('.player');
      siblings.forEach(sibling => {
        if (sibling !== player && sibling.classList.contains('winner')) {
          sibling.classList.remove('winner');
        }
      });

      // Update the next match with this player's name
      updateNextMatch(match, player);
    } else {
      // If no winner is selected, clear the next match slot
      clearNextMatchSlot(match);
    }
  }

  // Function to update the next match with the winner's name
  function updateNextMatch(match, winnerPlayer) {
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);

    // Find the next match element
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);
    if (!nextMatch) return;

    // Determine if this is the upper or lower player in the next match
    const isUpper = matchIndex % 2 === 0;
    const playerIndex = isUpper ? 0 : 1;

    // Get the player elements in the next match
    const nextMatchPlayers = nextMatch.querySelectorAll('.player');
    if (nextMatchPlayers.length <= playerIndex) return;

    // Update the player text in the next match
    const playerName = winnerPlayer.textContent;
    nextMatchPlayers[playerIndex].textContent = playerName;

    // Check if the player in the next match is already marked as a winner
    // If so, we need to propagate this change up the bracket
    if (nextMatchPlayers[playerIndex].classList.contains('winner')) {
      // Recursively update the next match up the bracket
      updateNextMatch(nextMatch, nextMatchPlayers[playerIndex]);
    }

    // Check if all matches in this round have winners
    checkRoundCompletion(round);
  }

  // Function to check if all matches in a round have winners and update the check mark
  function checkRoundCompletion(round) {
    // Get all matches in this round
    const matches = document.querySelectorAll(`.match[data-round="${round}"]`);
    let allCompleted = true;

    // Check if each match has a winner
    matches.forEach(match => {
      const winners = match.querySelectorAll('.player.winner');
      if (winners.length === 0) {
        allCompleted = false;
      }
    });

    // Update the check mark visibility
    const columnName = document.querySelector(`.column-name[data-round="${round}"]`);
    if (columnName) {
      const checkMark = columnName.querySelector('.check-mark');
      if (checkMark) {
        if (allCompleted) {
          checkMark.classList.add('visible');
        } else {
          checkMark.classList.remove('visible');
        }
      }
    }
  }

  // Function to clear the next match slot when no winner is selected
  function clearNextMatchSlot(match) {
    const round = parseInt(match.dataset.round);
    const matchIndex = parseInt(match.dataset.match);
    const nextRound = round + 1;
    const nextMatchIndex = Math.floor(matchIndex / 2);

    // Find the next match element
    const nextMatch = document.querySelector(`.match[data-round="${nextRound}"][data-match="${nextMatchIndex}"]`);
    if (!nextMatch) return;

    // Determine if this is the upper or lower player in the next match
    const isUpper = matchIndex % 2 === 0;
    const playerIndex = isUpper ? 0 : 1;

    // Get the player elements in the next match
    const nextMatchPlayers = nextMatch.querySelectorAll('.player');
    if (nextMatchPlayers.length <= playerIndex) return;

    // Check if the player in the next match is already marked as a winner
    // If so, we need to clear all matches up the bracket
    const wasWinner = nextMatchPlayers[playerIndex].classList.contains('winner');

    // Check if all matches in this round have winners (will update to false)
    checkRoundCompletion(round);

    // Check if the next match is the champion round (last round)
    const nextRoundNum = parseInt(nextMatch.dataset.round);
    const numRounds = document.querySelectorAll('.bracket-column').length;
    const isChampionRound = nextRoundNum === numRounds - 1;

    if (isChampionRound) {
      // If this is the champion round, restore the "Champion" placeholder with trophy
      nextMatchPlayers[playerIndex].innerHTML = `Champion <span class="winner-trophy">🏆</span>`;
    } else {
      // Otherwise, reset the player text in the next match to the default with specific round name
      const sourceMatchNum = parseInt(match.querySelector('.match-number').textContent.replace('Match ', ''));
      const sourceRound = parseInt(match.dataset.round);

      // Get the round name for more specific winner text
      let roundName;
      const numRounds = document.querySelectorAll('.bracket-column').length;
      if (sourceRound === numRounds - 2) {
        roundName = "Finals";
      } else if (sourceRound === numRounds - 3) {
        roundName = "Semi-Finals";
      } else {
        roundName = `Round ${sourceRound + 1}`;
      }

      nextMatchPlayers[playerIndex].textContent = `Winner of ${roundName} Match ${sourceMatchNum}`;

      // If this player was a winner, we need to recursively clear the next match as well
      if (wasWinner) {
        // Remove the winner class first to prevent infinite recursion
        nextMatchPlayers[playerIndex].classList.remove('winner');
        // Then recursively clear the next match
        clearNextMatchSlot(nextMatch);
      }
    }
  }

  // Function to generate the tournament bracket
  function generateBracket(numPlayers, playerNames = []) {
    const container = document.getElementById('tournament-container');
    container.innerHTML = '';

    // Calculate the number of rounds needed based on the ceiling of log2
    // Add 1 to include the champion round
    const numRounds = Math.ceil(Math.log2(numPlayers)) + 1;

    // Store match elements for each round to create connectors later
    const matchesByRound = [];

    // Store the match sources to track which matches feed into which
    const matchSources = {};

    // Calculate the number of players that get a "bye" in the first round
    const totalMatchesNeeded = numPlayers - 1; // Total matches needed for a tournament
    // Subtract 1 from numRounds to account for the champion round
    const firstRoundMatches = Math.max(0, numPlayers - Math.pow(2, numRounds - 2)); // Matches in the first round
    const byeCount = Math.pow(2, numRounds - 1) - numPlayers; // Number of players that get a bye

    // Generate each round
    for (let round = 0; round < numRounds; round++) {
      const column = document.createElement('div');
      column.className = 'bracket-column';
      column.dataset.round = round;

      // Add column name (skip for the champion column)
      if (round !== numRounds - 1) {
        let columnName;
        if (round === numRounds - 2) {
          columnName = "Finals";
        } else if (round === numRounds - 3) {
          columnName = "Semi-Finals";
        } else if (round === numRounds - 4) {
          columnName = "Quarter-Finals";
        } else {
          columnName = `Round ${round + 1}`;
        }

        // Create column name element
        const columnNameElement = document.createElement('div');
        columnNameElement.className = 'column-name';
        columnNameElement.innerHTML = columnName + ' <span class="check-mark">✓</span>';
        columnNameElement.dataset.round = round;
      }

      // Calculate the number of matches in this round
      let numMatches;
      if (round === 0) {
        // First round has matches for players without byes
        numMatches = firstRoundMatches;
      } else if (round === numRounds - 1 || round === numRounds - 2) {
        // Finals and Champion rounds always have 1 match
        numMatches = 1;
      } else {
        // Intermediate rounds
        // Calculate how many matches we need in this round based on the previous round
        // and the number of players with byes that enter in this round
        if (round === 1 && firstRoundMatches === 0) {
          // Special case: if there are no first round matches (power of 2),
          // then the second round has numPlayers/2 matches
          numMatches = numPlayers / 2;
        } else if (round === 1) {
          // Second round combines winners from first round and players with byes
          numMatches = Math.ceil(firstRoundMatches / 2) + Math.floor(byeCount / 2);
        } else {
          // Later rounds just have half as many matches as the previous round
          numMatches = Math.ceil(matchesByRound[round-1].length / 2);
        }
      }

      // Calculate the minimum height needed based on the number of matches in the first round
      // Each match needs at least 80px of vertical space (2 players + margins)
      // We convert this to vh units for consistent sizing
      const minHeightPerMatch = 10; // in vh units

      // Calculate the total height needed for the first round
      // We use the maximum of the default height (40vh) and the calculated height
      const calculatedTotalHeight = firstRoundMatches > 0
        ? Math.max(40, firstRoundMatches * minHeightPerMatch)
        : 40; // Default to 40vh for power-of-two tournaments

      // Set the height of the column
      column.style.height = `${calculatedTotalHeight}vh`;

      // Use the same totalHeight for positioning calculations
      const totalHeight = calculatedTotalHeight;

      // Store matches for this round
      matchesByRound[round] = [];

      // Generate the matches for this round
      for (let match = 0; match < numMatches; match++) {
        const matchElement = document.createElement('div');
        matchElement.className = 'match';
        matchElement.dataset.round = round;
        matchElement.dataset.match = match;

        // Position matches using absolute positioning
        // For non-power-of-two tournaments, we need to adjust the positioning

        // Calculate the total slots in the final round (always power of 2)
        // Subtract 1 from numRounds to account for the champion round
        const finalRoundSlots = Math.pow(2, numRounds - 2);

        // For the first round with non-power-of-two players
        if (round === 0) {
          // Calculate the position based on match index, accounting for byes
          const positionPercentage = ((match + 0.5) / (firstRoundMatches > 0 ? firstRoundMatches : 1)) * totalHeight;

          // Set absolute positioning
          matchElement.style.position = 'absolute';
          matchElement.style.top = positionPercentage + 'vh';
        } else {
          // For later rounds, position matches to align with their predecessors
          // Calculate the position of this match in the binary tree
          const matchPosition = match + 0.5;

          // Calculate the percentage of the total height
          const positionPercentage = (matchPosition / (numMatches > 0 ? numMatches : 1)) * totalHeight;

          // Set absolute positioning for precise pyramid alignment
          matchElement.style.position = 'absolute';
          matchElement.style.top = positionPercentage + 'vh';
        }

        // Add match number
        const matchNumber = document.createElement('div');
        matchNumber.className = 'match-number';

        // Calculate match number based on round and match index
        let matchNumberValue;
        if (round === 0) {
          matchNumberValue = match + 1;
        } else {
          // For later rounds, calculate based on previous rounds
          let previousRoundsMatches = 0;
          for (let r = 0; r < round; r++) {
            previousRoundsMatches += matchesByRound[r].length;
          }
          matchNumberValue = previousRoundsMatches + match + 1;
        }

        matchNumber.textContent = `Match ${matchNumberValue}`;
        matchElement.appendChild(matchNumber);

        // Create a unique ID for this match
        const matchId = `r${round}m${match}`;
        matchElement.dataset.matchId = matchId;

        if (round === 0) {
          // First round - create player pairings
          const player1 = document.createElement('div');
          player1.className = 'player';
          player1.textContent = playerNames[match * 2] || `Player ${match * 2 + 1}`;
          player1.addEventListener('click', handlePlayerClick);

          const player2 = document.createElement('div');
          player2.className = 'player';
          player2.textContent = playerNames[match * 2 + 1] || `Player ${match * 2 + 2}`;
          player2.addEventListener('click', handlePlayerClick);

          matchElement.appendChild(player1);
          matchElement.appendChild(player2);

          // Track which match in the next round this match feeds into
          // For non-power-of-two tournaments, the mapping might be different
          // We need to ensure matches are paired correctly in the next round
          let nextRoundMatch;

          if (round === 0 && firstRoundMatches < numPlayers / 2) {
            // For the first round in non-power-of-two tournaments,
            // we need to calculate which match in the next round this feeds into
            nextRoundMatch = Math.floor(match / 2);
          } else {
            // Standard pairing
            nextRoundMatch = Math.floor(match / 2);
          }

          const nextMatchId = `r${round + 1}m${nextRoundMatch}`;

          if (!matchSources[nextMatchId]) {
            matchSources[nextMatchId] = [];
          }
          matchSources[nextMatchId].push({
            matchId,
            isUpper: match % 2 === 0
          });

        } else if (round === numRounds - 1) {
          // Champion round - show the winner
          const winner = document.createElement('div');
          winner.className = 'player winner';
          winner.innerHTML = `Champion <span class="winner-trophy">🏆</span>`;
          matchElement.appendChild(winner);
        } else {
          // Intermediate rounds
          // For non-power-of-two tournaments, we need to handle players with byes

          // Get the sources for this match
          const sources = matchSources[matchId] || [];

          // If we have fewer than 2 sources, some players had byes
          if (sources.length < 2) {
            // First player might be from a previous match or have a bye
            if (sources.length > 0 && sources[0].isUpper) {
              // Player from previous match
              const player1 = document.createElement('div');
              player1.className = 'player';
              const sourceMatchNum = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
              const sourceRound = parseInt(sources[0].matchId.substring(1, sources[0].matchId.indexOf('m')));

              // Get the round name for more specific winner text
              let roundName;
              if (sourceRound === numRounds - 2) {
                roundName = "Finals";
              } else if (sourceRound === numRounds - 3) {
                roundName = "Semi-Finals";
              } else {
                roundName = `Round ${sourceRound + 1}`;
              }

              player1.textContent = `Winner of ${roundName} Match ${sourceMatchNum}`;
              player1.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player1);
            } else {
              // Player with a bye
              const player1 = document.createElement('div');
              player1.className = 'player';
              // Calculate player number based on round and match
              // For the first round with byes, we need to assign player numbers correctly
              // Players with byes start at firstRoundMatches*2+1
              const playerNum = firstRoundMatches * 2 + 1 + (match * 2);
              player1.textContent = playerNames[playerNum - 1] || `Player ${playerNum}`;
              player1.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player1);
            }

            // Second player might be from a previous match or have a bye
            if (sources.length > 0 && !sources[0].isUpper) {
              // Player from previous match
              const player2 = document.createElement('div');
              player2.className = 'player';
              const sourceMatchNum = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
              const sourceRound = parseInt(sources[0].matchId.substring(1, sources[0].matchId.indexOf('m')));

              // Get the round name for more specific winner text
              let roundName;
              if (sourceRound === numRounds - 2) {
                roundName = "Finals";
              } else if (sourceRound === numRounds - 3) {
                roundName = "Semi-Finals";
              } else {
                roundName = `Round ${sourceRound + 1}`;
              }

              player2.textContent = `Winner of ${roundName} Match ${sourceMatchNum}`;
              player2.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player2);
            } else {
              // Player with a bye
              const player2 = document.createElement('div');
              player2.className = 'player';
              // Calculate player number based on round and match
              // For the first round with byes, we need to assign player numbers correctly
              // Players with byes start at firstRoundMatches*2+1
              const playerNum = firstRoundMatches * 2 + 1 + (match * 2 + 1);
              player2.textContent = playerNames[playerNum - 1] || `Player ${playerNum}`;
              player2.addEventListener('click', handlePlayerClick);
              matchElement.appendChild(player2);
            }
          } else {
            // Normal case - both players from previous matches
            const player1 = document.createElement('div');
            player1.className = 'player';
            const sourceMatchNum1 = parseInt(sources[0].matchId.substring(sources[0].matchId.indexOf('m') + 1)) + 1;
            const sourceRound1 = parseInt(sources[0].matchId.substring(1, sources[0].matchId.indexOf('m')));

            // Get the round name for more specific winner text
            let roundName1;
            if (sourceRound1 === numRounds - 2) {
              roundName1 = "Finals";
            } else if (sourceRound1 === numRounds - 3) {
              roundName1 = "Semi-Finals";
            } else {
              roundName1 = `Round ${sourceRound1 + 1}`;
            }

            player1.textContent = `Winner of ${roundName1} Match ${sourceMatchNum1}`;
            player1.addEventListener('click', handlePlayerClick);

            const player2 = document.createElement('div');
            player2.className = 'player';
            const sourceMatchNum2 = parseInt(sources[1].matchId.substring(sources[1].matchId.indexOf('m') + 1)) + 1;
            const sourceRound2 = parseInt(sources[1].matchId.substring(1, sources[1].matchId.indexOf('m')));

            // Get the round name for more specific winner text
            let roundName2;
            if (sourceRound2 === numRounds - 2) {
              roundName2 = "Finals";
            } else if (sourceRound2 === numRounds - 3) {
              roundName2 = "Semi-Finals";
            } else {
              roundName2 = `Round ${sourceRound2 + 1}`;
            }

            player2.textContent = `Winner of ${roundName2} Match ${sourceMatchNum2}`;
            player2.addEventListener('click', handlePlayerClick);

            matchElement.appendChild(player1);
            matchElement.appendChild(player2);
          }

          // Track which match in the next round this match feeds into
          if (round < numRounds - 1) {
            // For intermediate rounds and finals, calculate which match in the next round this feeds into
            // Standard pairing for binary tournament
            const nextRoundMatch = Math.floor(match / 2);
            const nextMatchId = `r${round + 1}m${nextRoundMatch}`;

            if (!matchSources[nextMatchId]) {
              matchSources[nextMatchId] = [];
            }
            matchSources[nextMatchId].push({
              matchId,
              isUpper: match % 2 === 0
            });
          }
        }

        // Store the match element for later connector creation
        matchesByRound[round][match] = matchElement;

        column.appendChild(matchElement);
      }

      container.appendChild(column);
    }

    // Add column names to the DOM and position them
    setTimeout(() => {
      const columns = document.querySelectorAll('.bracket-column');
      columns.forEach((column, index) => {
        const round = parseInt(column.dataset.round);

        // Skip the champion column (last round)
        if (round === numRounds - 1) {
          return;
        }

        const columnRect = column.getBoundingClientRect();
        const columnName = document.createElement('div');
        columnName.className = 'column-name';

        // Set the column name based on the round
        let columnNameText;
        if (round === numRounds - 2) {
          columnNameText = "Finals";
        } else if (round === numRounds - 3) {
          columnNameText = "Semi-Finals";
        } else if (round === numRounds - 4) {
          columnNameText = "Quarter-Finals";
        } else {
          columnNameText = `Round ${round + 1}`;
        }

        columnName.innerHTML = columnNameText + ' <span class="check-mark">✓</span>';
        columnName.dataset.round = round;

        // Position the column name under the center of the column
        const centerX = columnRect.left + columnRect.width / 2;
        columnName.style.left = `${centerX}px`;

        document.body.appendChild(columnName);
      });

      // Update column name positions when zooming or panning
      const updateColumnNamePositions = () => {
        const columns = document.querySelectorAll('.bracket-column');
        const columnNames = document.querySelectorAll('.column-name');

        columns.forEach((column, index) => {
          const columnRect = column.getBoundingClientRect();
          const centerX = columnRect.left + columnRect.width / 2;
          columnNames[index].style.left = `${centerX}px`;
        });
      };

      // Add event listeners for zoom and pan events
      const zoomContainer = document.querySelector('.zoom-container');
      const zoomContent = document.querySelector('.zoom-content');

      // Use MutationObserver to detect changes to the transform style
      const observer = new MutationObserver(updateColumnNamePositions);
      observer.observe(zoomContent, { attributes: true, attributeFilter: ['style'] });

      // Also update positions on window resize
      window.addEventListener('resize', updateColumnNamePositions);

      // Initialize check marks for all rounds
      for (let i = 0; i < numRounds; i++) {
        checkRoundCompletion(i);
      }
    }, 100);

    // Create curved connectors between match pairings and their next-level match
    // For each match, find its sources and create connectors
    for (let round = 1; round < numRounds; round++) {
      for (let match = 0; match < matchesByRound[round].length; match++) {
        const targetMatch = matchesByRound[round][match];
        const targetMatchId = `r${round}m${match}`;
        const sources = matchSources[targetMatchId] || [];

        // Create connectors for each source
        for (const source of sources) {
          // Find the source match element
          const sourceRound = parseInt(source.matchId.substring(1, source.matchId.indexOf('m')));
          const sourceMatch = parseInt(source.matchId.substring(source.matchId.indexOf('m') + 1));
          const sourceMatchElement = matchesByRound[sourceRound][sourceMatch];

          // Create curved connector between this match and its target
          const curvedConnector = createCurvedConnector(sourceMatchElement, targetMatch, container, source.isUpper);
          container.appendChild(curvedConnector);
        }
      }
    }
  }
</script>
</body>
</html>
<script>
  (function() {
    var ws = new WebSocket('ws://' + window.location.host +
      '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
      'referrer=' + encodeURIComponent(window.location.pathname));
    ws.onmessage = function (msg) {
      if (msg.data === 'reload') {
        window.location.reload();
      }
      if (msg.data.startsWith('update-css ')) {
        var messageId = msg.data.substring(11);
        var links = document.getElementsByTagName('link');
        for (var i = 0; i < links.length; i++) {
          var link = links[i];
          if (link.rel !== 'stylesheet') continue;
          var clonedLink = link.cloneNode(true);
          var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
          if (newHref !== link.href) {
            clonedLink.href = newHref;
          }
          else {
            var indexOfQuest = newHref.indexOf('?');
            if (indexOfQuest >= 0) {
              // to support ?foo#hash
              clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' +
                newHref.substring(indexOfQuest + 1);
            }
            else {
              clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
            }
          }
          link.replaceWith(clonedLink);
        }
      }
    };
  })();
</script>
