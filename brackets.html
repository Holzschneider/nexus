<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Nexus Bracket</title>
<script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
<style>
html, body {
    margin: 0;
    height: 100%;
}
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1f4037, #99f2c8);
    overflow: hidden;
    color: #333;
}
.viewport {
    position: relative;
    width: 100%;
    height: 100%;
    touch-action: none;
}
.board {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(1);
    transform-origin: 0 0;
}
.bracket {
    border-collapse: separate;
    border-spacing: 20px;
}
.match {
    background: #fff;
    border-radius: 8px;
    padding: 12px 16px;
    min-width: 160px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    font-weight: 500;
}
.reset {
    position: absolute;
    bottom: 20px;
    right: 20px;
    border: none;
    background: #0069d9;
    color: #fff;
    padding: 10px 16px;
    border-radius: 20px;
    font-weight: bold;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    cursor: pointer;
}
[x-cloak] { display: none !important; }
</style>
</head>
<body x-data="bracketApp()" x-init="init()" @wheel.prevent="onWheel" @mousedown="startDrag" @touchstart="startDrag" @mousemove="drag" @touchmove="drag" @mouseup="endDrag" @touchend="endDrag" @mouseleave="endDrag">
<div class="viewport">
  <div class="board" x-ref="board" :style="`transform:translate(-50%, -50%) translate(${offset.x}px, ${offset.y}px) scale(${zoom})`">
    <table class="bracket"></table>
  </div>
  <button class="reset" x-show="Math.abs(zoom-1) > 0.01" x-cloak @click="reset">100%</button>
</div>
<script>
function buildBracket(playerCount) {
    const rounds = Math.ceil(Math.log2(playerCount));
    const bracketSize = Math.pow(2, rounds);
    const players = [];
    for (let i = 1; i <= playerCount; i++) {
        players.push(`Player ${i}`);
    }
    for (let i = playerCount + 1; i <= bracketSize; i++) {
        players.push('BYE');
    }
    const rows = bracketSize / 2;
    const table = document.querySelector('.bracket');
    const rowEls = [];
    for (let r = 0; r < rows; r++) {
        const tr = document.createElement('tr');
        table.appendChild(tr);
        rowEls.push(tr);
    }
    // first round pairings
    for (let i = 0; i < rows; i++) {
        const td = document.createElement('td');
        td.className = 'match round-1';
        td.textContent = players[i*2] + ' vs ' + players[i*2+1];
        rowEls[i].appendChild(td);
    }
    // subsequent rounds
    for (let r = 2; r <= rounds; r++) {
        const matchCount = bracketSize / Math.pow(2, r);
        const span = Math.pow(2, r-1);
        for (let m = 0; m < matchCount; m++) {
            const td = document.createElement('td');
            td.className = 'match round-' + r;
            td.rowSpan = span;
            td.textContent = r === rounds ? 'Winner' : 'Advances';
            rowEls[m*span].appendChild(td);
        }
    }
}

function bracketApp() {
    return {
        zoom: 1,
        minZoom: 0.5,
        maxZoom: 3,
        offset: {x: 0, y: 0},
        dragging: false,
        dragStart: {x: 0, y: 0},
        offsetStart: {x: 0, y: 0},
        pinch: false,
        pinchStart: 0,
        pinchZoomStart: 1,
        init() {
            const params = new URLSearchParams(window.location.search);
            let count = parseInt(params.get('players'), 10);
            if (isNaN(count) || count < 2) count = 8;
            buildBracket(count);
        },
        reset() {
            this.zoom = 1;
            this.offset = {x: 0, y: 0};
        },
        getPos(e) {
            if (e.touches) {
                return {x: e.touches[0].clientX, y: e.touches[0].clientY};
            }
            return {x: e.clientX, y: e.clientY};
        },
        startDrag(e) {
            if (e.touches && e.touches.length === 2) {
                this.pinch = true;
                this.pinchStart = this.getPinchDistance(e);
                this.pinchZoomStart = this.zoom;
            } else {
                this.dragging = true;
                const pos = this.getPos(e);
                this.dragStart = pos;
                this.offsetStart = {...this.offset};
            }
        },
        drag(e) {
            if (this.pinch && e.touches && e.touches.length === 2) {
                e.preventDefault();
                const dist = this.getPinchDistance(e);
                const scale = dist / this.pinchStart;
                const newZoom = this.pinchZoomStart * scale;
                const pos = {x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                             y: (e.touches[0].clientY + e.touches[1].clientY) / 2};
                this.applyZoom(newZoom, pos);
            } else if (this.dragging) {
                const pos = this.getPos(e);
                this.offset.x = this.offsetStart.x + pos.x - this.dragStart.x;
                this.offset.y = this.offsetStart.y + pos.y - this.dragStart.y;
            }
        },
        endDrag() {
            this.dragging = false;
            this.pinch = false;
        },
        onWheel(e) {
            const delta = e.deltaY < 0 ? 0.1 : -0.1;
            const rect = this.$refs.board.getBoundingClientRect();
            const origin = {x: e.clientX - rect.left, y: e.clientY - rect.top};
            this.applyZoom(this.zoom + delta, origin);
        },
        getPinchDistance(e) {
            const [t0, t1] = e.touches;
            return Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY);
        },
        applyZoom(newZoom, origin) {
            newZoom = Math.min(this.maxZoom, Math.max(this.minZoom, newZoom));
            const factor = newZoom / this.zoom;
            this.offset.x = origin.x - factor * (origin.x - this.offset.x);
            this.offset.y = origin.y - factor * (origin.y - this.offset.y);
            this.zoom = newZoom;
        }
    };
}
</script>
</body>
</html>
